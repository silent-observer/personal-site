<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЭУМК</title>
    <link rel="stylesheet" href="../../styles/styles.css">
</head>
<body class="dark">
    <div class="container">
        <header>
            <h1>Основы Rust</h1>
            <nav>
                <ul>
                    <li><a href="index.html">Главная</a></li>
                    <li><a href="curriculum.html">Программа</a></li>
                    <li><a href="sources.html">Источники</a></li>
                    <li><a href="materials.html">Учебный материал</a></li>
                    <li><a href="tests.html">Тесты</a></li>
                    <li><a href="tasks.html">Задания</a></li>
                    <li><a href="../index.html">Об авторе</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <section>
                <h2>Рабочая учебная программа</h2>
                <h3>Цель изучения</h3>
                <p>Цель изучения данного учебного курса заключается в освоении концепций безопасной работы с памятью с использованием языка Rust, а также в умении эффективно создавать безопасные приложения, обладающие высокой производительностью.</p>
                <h3>Задачи данного учебного курса</h3>
                <ol>
                    <li><b>Изучение основ безопасности памяти в контексте языка программирования Rust</b>: ознакомить студентов с ключевыми концепциями и принципами, такими как ошибки use-after-free, мутабельность, aliasing, borrow checker и др.</li>
                    <li><b>Практическое применение технологий</b>: научить студентов проектировать и разрабатывать приложения, использующие методики безопасности памяти, а также применять полученные знания для решения практических задач.</li>
                </ol>
                <h3>Знания, умения и навыки</h3>
                <ol>
                    <li><b>Знания о механизмах безопасности</b>: уметь объяснять основные принципы работы с памятью в Rust.</li>
                    <li><b>Навыки разработки безопасных приложений</b>: научиться реализовывать безопасных приложения, использование различных механизмов безопасности памяти и взаимодействие между ними.</li>
                    <li><b>Умение оптимизировать производительность приложений</b>: способность анализировать производительность кода и оптимизировать структуры данных для достижения высокой эффективности работы приложений.</li>
                </ol>
                <h3>Основные результаты деятельности обучения</h3>
                <p>Студенты, прошедшие курс, смогут использовать язык Rust для написания безопасных приложений без уязвимостей связанных с нарушениями безопасности памяти.</p>
                <h3>Основные разделы курса</h3>
                <p>Данный курс содержит следующие разделы:</p>
                <ol>
                    <li>Основы Rust (2 академических часа)</li>
                    <li>Безопасность памяти (4 академических часа)</li>
                    <li>Borrow checker (4 академических часа)</li>
                </ol>
            </section>
            <section>
                <h2>Краткое содержание теоретической и практической части</h2>
                <h3>Основы Rust</h3>
                <p>В разделе “Основы Rust” рассматриваются самые базовые концепции программирования на Rust, его синтаксис и особенности, такие как алгебраические типы, дженерики и трейты.</p>
                <p>Алгебраические типы — это особый способ определения типов данных при помощи операций «суммы» и «произведения» типов. В Rust сумма типов известна как enum, а произведение как struct. Подобный структурированный способ определения типов позволяет математически доказывать правильность типов в программе, а также автоматически генерировать часть кода.</p>
                <p>Дженерики, также известные как параметрический полиморфизм типов — это механизм переиспользования кода, позволяющий написать функцию или тип данных с некоторым неизвестным заранее типом. Этот механизм широко используется и в других известных языках, но Rust обращает на него особое внимание.</p>
                <p>Трейты — это аналог интерфейсов в Rust (хотя они более близки к typeclass из Haskell). Особенностью трейтов в Rust является широкая их поддержка на этапе компиляции и, в связи с этим, широкое их использование как называемой «zero-cost abstraction» — абстракции, которая полностью убирается компилятором и компилируется в обычный (но менее эргономичный) код.</p>
                <p>В конце курса представлены контрольные вопросы, которые касаются различий между дженериками в Rust и Java, трейтами и интерфейсами, а также алгебраических типов. Также предлагаются упражнения для самостоятельной работы, такие как написание собственных алгебраических типов для описания деревьев, а также реализацию стандартной задачи для ООП при помощи алгебраических типов или трейтов.</p>
                <p>Этот раздел курса предоставляет базовые знания о программировании в Rust и практические примеры работы с его основными возможностями.</p>
                <p>Каждое задание включает критерии, которые помогут студентам правильно использовать особенности Rust. Основное внимание уделяется соотвествию идиоматике Rust, а также структурированности и чистоте кода.</p>
                
                <h3>Безопасность памяти</h3>
                <p>В разделе “Безопасность памяти” рассматриваются основные проблемы, которые могут возникнуть при неправильном обращении с памятью. Эти проблемы классифицируются на пространственные и временные, и временные в свою очередь классифицируются на use-after-free, double-free и uninitialized memory. Также рассматриваются стандартные способы борьбы с этими проблемами: garbage collector, reference counting, санитайзеры и RAII.</p>
                <p>Пространственная безопасность памяти (buffer overflow) — это требование, что программа никогда не осуществляла доступ за границей выделенных ей участков памяти. Чаще всего нарушение этой безопасности означает выход за границу массива и попытку чтения/записи данных. Buffer overflow является причиной большей частью всех уязвимостей в мире, но при этом достаточно легко решается — при помощи обязательных проверок на границы массива при каждом доступе.</p>
                <p>Временная безопасность памяти — это требование, чтобы программа осуществляла доступ к участкам памяти только после их инициализации и до ее освобождения (free). Попытка доступа до инициализации называется доступом к uninitialized memory, попытка доступа после освобождения памяти — use after free, а попытка освободить память еще раз уже после ее освобождения — double free.</p>
                <p>Сборщик мусора (garbage collector) — это механизм, обеспечивающий безопасность памяти путем полного контроля ее аллокации. Освобождение происходит тогда, когда сборщик мусора опеределяет, что больше не существует ссылок на нее.</p>
                <p>Reference counting — похожий механизм, но подсчет ссылок осуществляется в самой выделяемой памяти. Таким образом создание и удаление новых ссылок требует модификации счетчика, хранящегося в этой памяти.</p>
                <p>Санитайзер — внешняя библиотека/флаг компилятора, подключащаяся к программе при ее выполнении и проверяющая все проблемы с безопасностью памяти (или неопределенным поведением). Он значительно замедляет ее работу, в связи с чем его разумно использовать только при разработке и тестировании.</p>
                <p>RAII (Resource Acquisition Is Initalization) — это особенность некоторых языков, в которых есть понятие «ресурса» — объекта, который инициализируется при создании и автоматически удаляется при выходе из его зоны видимости. Rust широко использует этот механизм, в том числе рассматривая память как ресурс.</p>
                <p>В заключение раздел содержит контрольные вопросы и упражнения для самостоятельной работы, которые помогут закрепить полученные знания о безопасности памяти. Например, задачи включают поиск ошибок памяти в некоторых простых программах.</p>

                <h3>Borrow checker</h3>
                <p>В разделе “Borrow Checker” рассматриваются особенности borrow checker — механизма Rust для осуществления безопасности памяти. Рассматривается понятия мутабельности, алиасинга, lifetime, принцип aliasing XOR mutability, а также interior mutability.</p>
                <p>Мутабельность — это возможность изменять данные, хранящиеся в памяти. Данные, которые запрещено изменять (в принципе или в каком-то участке кода) называются иммутабельными. Важно обратить внимание на отличие с const в C++: const не является транзитивным, и поэтому означает иммутабельность только одной области данных. Иммутабельность в Rust чаще всего означает иммутабельность в том числе всех других областей, к которым можно получить доступ.</p>
                <p>Алиасинг — это присутствие нескольких ссылок на одну и ту же область памяти.</p>
                <p>Aliasing XOR mutability — один из основных принципов Rust: на каждую область памяти возможен или мутабельный доступ, или shared доступ (с алиасингом), но не одновременно.</p>
                <p>Interior mutability — это особый механизм обхода этого ограничения, с переносом его на время выполнения.</p>
            </section>
            <section>
                <h2>Перечень инструментальных средств</h2>
                <p>Для изучения курса понадобится любое устройство, поддерживающее современные браузеры для изучения теоретического материала и выполнения тестовых заданий. Также понадобится компьютер, поддерживающий компилятор Rust (рекомендуемая версия - Rust 1.83 и выше). Возможно также использовать песочницу Compiler Emulator (https://godbolt.org/) для более быстрой реализации заданий.</p>
                <h2>Перечень рекомендуемых источников:</h2>
                <ol>
                    <li>The Rust Programming Language. URL: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a> (дата обращения: 22.11.2023).</li>
                    <li>Rust by Example. URL: <a href="https://doc.rust-lang.org/rust-by-example/index.html">https://doc.rust-lang.org/rust-by-example/index.html</a> (дата обращения: 22.11.2023).</li>
                    <li>The Rust Standard Library. URL: <a href="https://doc.rust-lang.org/std/index.html">https://doc.rust-lang.org/std/index.html</a> (дата обращения: 22.11.2023).</li>
                    <li>Understanding the Rust Borrow Checker. URL: <a href="https://blog.logrocket.com/introducing-rust-borrow-checker/">https://blog.logrocket.com/introducing-rust-borrow-checker/</a> (дата обращения: 22.11.2023).</li>
                    <li>Borrow checking, RC, GC, and the Eleven (!) Other Memory Safety Approaches. URL: <a href="https://verdagon.dev/grimoire/grimoire">https://verdagon.dev/grimoire/grimoire</a> (дата обращения: 22.11.2023).</li>
                    <li>Memory in Non-Memory-Safe Languages. URL: <a href="https://verdagon.dev/blog/when-to-use-memory-safe-part-1">https://verdagon.dev/blog/when-to-use-memory-safe-part-1</a> (дата обращения: 22.11.2023).</li>
                </ol>
                <h2>Итоговый контроль</h2>
                <p>Формой итоговой контроля является зачёт.</p>
                <p>Оценка “зачтено” — Практические задания выполнены в полном объеме и имеют средний балл не ниже 60%. Студент демонстрирует правильные, уверенные действия по применению полученных знаний на практике, грамотное и логически стройное изложение материала при аргументации ответов на вопросы при защите лабораторных.</p>
                <p>Оценка «не зачтено» - Практические задания не выполнены в полном объеме и/или предоставлены со средним результатом ниже 60%, Студент демонстрирует наличие грубых ошибок в ответе, непонимание сущности излагаемого вопроса, неумение применять знания на практике, неуверенность и неточность ответов на дополнительные и наводящие вопросы.</p>
            </section>
        </main>

        <footer>
            <p>Подготовил Максим Мичков, 2024.</p>
        </footer>
    </div>
</body>
</html>
