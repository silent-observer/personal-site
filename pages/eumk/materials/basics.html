<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЭУМК</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>

    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="../../../styles/styles.css">
</head>
<body class="dark">
    <div class="container">
        <header>
            <h1>Основы Rust</h1>
            <nav>
                <ul>
                    <li><a href="../index.html">Главная</a></li>
                    <li><a href="../curriculum.html">Программа</a></li>
                    <li><a href="../sources.html">Источники</a></li>
                    <li><a href="../materials.html">Учебный материал</a></li>
                    <li><a href="../tests.html">Тесты</a></li>
                    <li><a href="../tasks.html">Задания</a></li>
                    <li><a href="../../index.html">Об авторе</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <section>
                <h2>Теоретический материал по разделу "Основы Rust"</h2>
                <p>Rust — это системный язык программирования, который сочетает в себе производительность C и C++ с современными концепциями безопасности и параллелизма. Он был разработан для предотвращения ошибок памяти и гонок данных без ущерба для производительности. Rust предоставляет выразительные средства работы с типами, безопасностью памяти, многозадачностью и параллелизмом. В этом разделе мы рассмотрим основы синтаксиса, алгебраические типы данных, дженерики и трейты, проводя параллели с языками C++ и Java.</p>
                <h3>Синтаксис</h3>
                <p>Синтаксис Rust в некоторой степени схож с C++, но при этом он предоставляет несколько удобных улучшений, упрощающих работу с кодом.</p>
                <h4>Переменные</h4>
                <p>В Rust переменные по умолчанию неизменяемы. Это принципиальное отличие от C++ и Java, где переменные обычно изменяемы. Чтобы сделать переменную изменяемой, нужно явно указать это с помощью ключевого слова mut.</p>
                <pre><code class="language-rust">
let x = 5; // неизменяемая переменная
let mut y = 10; // изменяемая переменная
y = 20; // допустимо, потому что y - изменяемая
                </code></pre>
                
                <p>Для типов данных Rust использует строгую типизацию, как в C++, но с возможностью вывода типов компилятором. Типы могут быть явно указаны или определяться компилятором.</p>
                <pre><code class="language-rust">
let a: i32 = 42; // явное указание типа
let b = 3.14; // тип будет выведен как f64
                </code></pre>
                <h4>Функции</h4>
                <p>Функции в Rust объявляются с использованием ключевого слова fn. Они могут принимать аргументы и возвращать значения. Типы аргументов и возвращаемых значений всегда явно указаны.</p>
                <pre><code class="language-rust">
fn add(x: i32, y: i32) -> i32 {
    x + y
}

let result = add(2, 3);
                </code></pre>
                <p>Также стоит отметить, что Rust поддерживает многострочные лямбда-выражения (аналогично C++ и Java) через анонимные функции:</p>
                <pre><code class="language-rust">
let square = |x: i32| -> i32 { x * x };
println!("{}", square(5)); // 25
                </code></pre>
                <h4>Управляющие конструкции</h4>
                <p>Rust поддерживает традиционные операторы управляющие конструкции, такие как if, else, match (аналог switch в C++ и Java), while, for. Оператор match является мощным инструментом для работы с алгебраическими типами, такими как перечисления (enum), но может использоваться и в других ситуациях:</p>
                <pre><code class="language-rust">
let number = 5;

if number > 10 {
    println!("Bigger than 10");
}

match number {
    1 => println!("One"),
    2 => println!("Two"),
    _ => println!("Other"), // _ — это wildcard, аналогично default в switch
}
                </code></pre>
                <h3>Алгебраические типы данных</h3>
                <p>Алгебраические типы данных (ADT) в Rust представляют собой комбинации типов, которые могут быть использованы для создания более сложных структур данных. В Rust два основных типа ADT: перечисления (enums) и структуры (structs).</p>
                <h4>Структуры (Structs)</h4>
                <p>Структуры в Rust — это коллекции связанных данных. Они похожи на структуры в C++, но с более строгой типизацией и удобными методами для работы с ними.</p>
                <pre><code class="language-rust">
struct Point {
    x: i32,
    y: i32,
}

let p = Point { x: 10, y: 20 };
                </code></pre>
                <p>Rust позволяет определять методы для структур, что делает их более гибкими. В отличие от C++ и Java, методы определяются в отдельном блоке impl:</p>
                <pre><code class="language-rust">
impl Point {
    fn new(x: i32, y: i32) -> Self {
        Point { x, y }
    }

    fn distance_from_origin(&self) -> f64 {
        ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt()
    }
}

let point = Point::new(3, 4);
println!("Distance: {}", point.distance_from_origin());
                </code></pre>
                <h4>Перечисления (Enums)</h4>
                <p>Перечисления в Rust — это типы, которые могут принимать несколько разных вариантов значений. </p>
                <pre><code class="language-rust">
enum Direction {
    Up,
    Down,
    Left,
    Right,
}

let move_direction = Direction::Up;
                </code></pre>
                <p>В отличие от C++, в Rust перечисления могут хранить дополнительные данные для каждого варианта. Это делает их мощным инструментом для создания гибких и безопасных API. Это близко объединениям (union) в C++, но в Rust каждый enum также содержит скрытое поле тэга, которое гарантирует что доступ осуществляется только к одному из вариантов:</p>
                <pre><code class="language-rust">
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
}

let move_msg = Message::Move { x: 10, y: 20 };
                </code></pre>
                <p>Это позволяет эффективно обрабатывать различные варианты с помощью конструкции match:</p>
                <pre><code class="language-rust">
match (msg) {
    Message::Quit => println!("Quitting!"),
    Message::Move{x, y} => println!("Moving to ({},{})", x, y),
    Message::Write(s) => println!("Writing \"{}\"", s),
}
                </code></pre>
                <h3>Дженерики</h3>
                <p>Дженерики в Rust позволяют создавать обобщённые функции и структуры, аналогично шаблонам в C++ или дженерикам в Java. В отличие от C++, где дженерики представляют собой макросы или специализированные типы, дженерики в Rust являются частью системы типов, поддерживая строгую типизацию во время компиляции. Также, аналогично шаблонам C++, при компиляции дженерики Rust просто дублируют код (так называемая мономорфизация), а не пишут универсальные функции и используют виртуальные таблицы, как это делает Java, что повышает  производительность дженериков в Rust.</p>
                <h4>Дженерики в функциях</h4>
                <p>Дженерики позволяют создавать универсальные функции, которые могут работать с любыми типами.</p>
                <pre><code class="language-rust">
fn print_value<T>(value: T) {
    println!("{:?}", value);
}

print_value(42); // тип T будет определён как i32
print_value("Hello"); // тип T будет определён как &str
                </code></pre>
                <h4>Дженерики в структурах</h4>
                <p>Можно также использовать дженерики в структурах и методах для создания универсальных типов данных.</p>
                <pre><code class="language-rust">
struct Wrap<T> {
    value: T,
}

impl<T> Wrap<T> {
    fn new(value: T) -> Self {
        Wrap { value }
    }

    fn get_value(&self) -> &T {
        &self.value
    }
}

let b = Wrap::new(42);
println!("Value: {}", b.get_value());
                </code></pre>
                <h4>Ограничения для дженериков</h4>
                <p>В Rust можно накладывать ограничения на типы дженериков, используя трейты (о которых речь пойдёт ниже). Это позволяет создавать более точные и безопасные обобщённые функции.</p>
                <pre><code class="language-rust">
fn print_debug<T: std::fmt::Debug>(value: T) {
    println!("{:?}", value);
}

print_debug("Hello, world!");
                </code></pre>
                <h3>Трейты</h3>
                <p>Трейты в Rust — это аналог интерфейсов в Java и абстрактных классов в C++. Они определяют набор методов, которые тип должен реализовать. Трейты позволяют создавать абстракции, которые могут быть реализованы для различных типов данных, что позволяет легко строить универсальные и расширяемые программы.</p>
                <h4>Определение трейта</h4>
                <p>Трейт — это набор методов, которые тип должен реализовать.</p>
                <pre><code class="language-rust">
trait Speak {
    fn speak(&self);
}
                </code></pre>

                <h4>Реализация трейтов</h4>
                <p>Типы могут реализовывать трейты с помощью ключевого слова impl.</p>
                <pre><code class="language-rust">
struct Dog;
struct Cat;

impl Speak for Dog {
    fn speak(&self) {
        println!("Woof!");
    }
}

impl Speak for Cat {
    fn speak(&self) {
        println!("Meow!");
    }
}
                </code></pre>
                <h4>Использование трейтов</h4>
                <p>После того как тип реализует трейт, его методы можно использовать:</p>
                <pre><code class="language-rust">
let dog = Dog;
let cat = Cat;

dog.speak();
cat.speak();
                </code></pre>
                <p>Трейты позволяют делать код более абстрактным и модульным, поддерживая высокую степень гибкости и композиции.</p>
            </section>
            <section>
                <h2>Контрольные вопросы</h2>
                <ol>
                    <li>Что такое алгебраические типы данных в Rust, и как перечисления (enums) отличаются от структур (structs)? Приведите пример использования каждого из этих типов.</li>
                    <li>Как дженерики в Rust позволяют создавать универсальные функции и структуры? Объясните, как ограничения на дженерики могут быть использованы для уточнения типов. Приведите пример использования дженериков с ограничением.</li>
                    <li>Что такое трейты в Rust, и как они помогают реализовывать полиморфизм? Приведите пример создания и использования трейта в Rust.</li>
                    <li>Какие ключевые отличия синтаксиса Rust от C++ и Java вы заметили?</li>
                    <li>Какие особенности синтаксиса Rust делают его более безопасным по сравнению с C++ и Java, особенно в контексте работы с переменными и типами данных? Приведите примеры работы с неизменяемыми и изменяемыми переменными.</li>
                </ol>

                <h2>Упражнения для самостоятельной работы</h2>
                <h3>Задачи</h3>
                <ol>
                    <li>Определите бинарное дерево, имеющее целое число в каждом из листьев, при помощи алгебраического типа. Подсказка: дженерик Box&lt;T&gt; можно использовать как указатель на T.</li>
                    <li>Преобразуйте бинарное дерево из предыдущего упражнения в дженерик, сделав тип данных внутри него произвольным.</li>
                    <li>Напишите дженерик-функцию для суммирования чисел произвольного типа.</li>
                </ol>

                <h3>Пример выполнения упражнения</h3>
                <p><strong>Упражнение:</strong> Преобразуйте бинарное дерево из предыдущего упражнения в дженерик, сделав тип данных внутри него произвольным.</p>
                <pre><code class="language-rust">
enum Tree&lt;T&gt; {
    Leaf(T), // Лист с данными типа T
    Internal { // Внутренний узел
        left: Box&lt;Tree&lt;T&gt;&gt;, 
        right: Box&lt;Tree&lt;T&gt;&gt;
    },
}
                </pre></code>
            </section>
        </main>

        <footer>
            <p>Подготовил Максим Мичков, 2024.</p>
        </footer>
    </div>
</body>
</html>
