<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЭУМК</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>

    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="../../../styles/styles.css">
</head>
<body class="dark">
    <div class="container">
        <header>
            <h1>Основы Rust</h1>
            <nav>
                <ul>
                    <li><a href="../index.html">Главная</a></li>
                    <li><a href="../curriculum.html">Программа</a></li>
                    <li><a href="../sources.html">Источники</a></li>
                    <li><a href="../materials.html">Учебный материал</a></li>
                    <li><a href="../tests.html">Тесты</a></li>
                    <li><a href="../tasks.html">Задания</a></li>
                    <li><a href="../../index.html">Об авторе</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <section>
                <h2>Теоретический материал по разделу "Безопасность памяти"</h2>
                
                <h3>Введение в систему владения и заимствований</h3>
                <p>Все объекты в Rust по умолчанию представляют собой так называемые «ресурсы». Каждый ресурс в программе всегда имеет владельца — переменную или структуру, которая управляет этим ресурсом. Программа в любой момент времени может иметь только один владельца ресурса, и его переходы должны быть явными.</p>
                
                <p>Основные правила владения и заимствования:</p>
                <ul>
                    <li>Каждый ресурс имеет один владельца.</li>
                    <li>Присваивание переменной или вызов функции передает владение. При этом старый владелец уже не может использовать ресурс.</li>
                    <li>Ресурс может быть заимствован (borrow) с правом на чтение или запись, но существует строгие ограничения на то, как и когда это может происходить.</li>
                </ul>
                <p>Основная задача borrow checker в Rust — это проверка правил заимствований и гарантирование того, что они соблюдаются на уровне компиляции.</p>
                
                <h3>Ссылки и мутабельность</h3>
                <p>В Rust можно работать с двумя типами ссылок: immutable и mutable.</p>
                <p>Immutable ссылка — это ссылка, которая позволяет только читать данные, но не изменять их. Например, если функция принимает immutable ссылку, то попытка ее изменения выдаст ошибку при компиляции:</p>
                
                <pre><code class="language-rust">
fn try_modify(x: &int) {
*x += 1; // ошибка!
                }</code></pre>
                
                <p>Mutable ссылка не имеет таких ограничений, и позволяет в том числе изменять данные, на которые она указывает. Mutable ссылку всегда можно преобразовать в immutable, но не наоборот. Также, невозможно взять mutable ссылку на immutable переменную:</p>
                
                <pre><code class="language-rust">
fn main() {
    let x: i32 = 42;
    let y: &mut i32 = &mut x; // ошибка!
}
                </code></pre>
                
                <h3>Алиасинг</h3>
                <p>Rust позволяет создать несколько immutable ссылок на один и тот же ресурс:</p>
                
                <pre><code class="language-rust">
fn main() {
    let x = 5;
    let y = &x; // ссылка на x
    let z = &x; // ещё одна ссылка на x

    println!("y: {}, z: {}", y, z);
}
            </code></pre>
                
                <p>Здесь, y и z могут одновременно ссылаться на переменную x.</p>
                
                <h3>Aliasing XOR Mutability</h3>
                <p>Одно из ключевых правил Rust: иметь aliasing и mutability одновременно запрещено: у нас может быть или ровно одна mutable ссылка, или много immutable. В связи с этим mutable ссылки можно скорее рассматривать как уникальные, дающие гарантию что на этот объект нет никаких других ссылок, а immutable ссылки этой гарантии не дают.</p>
                
                <p>Пример:</p>
                
            <pre><code class="language-rust">
fn main() {
    let mut x = 5;
    let y = &x; // immutable ссылка
    let z = &mut x; // ошибка: не можем создать mutable ссылку, когда есть другая
}
            </code></pre>
                
                <p>Ошибка компиляции:</p>
                <pre><code>error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable</code></pre>
                
                <p>Это важное ограничение существует в связи с тем, что shared mutability несет большое число проблем как для параллелизма, так и для написания поддерживаемого ПО. В Rust разрешено передавать ссылки в том числе в другие потоки, и это означает, что несколько ссылок на одни и те же данные могут оказаться в разных потоках. Тогда если хотя бы одна из этих ссылок mutable, то у других потоков значение по их (неизменяемой) ссылке может меняться в произвольные моменты времени (аналогично volatile в C). Это может привести к гонкам данных, уязвимостям, или к просто очень сложному коду. Даже если многопоточность не используется в программе, запрет на shared mutability позволяет гарантировать, что если у функции имеется immutable ссылка на что-то, этот объект не может измениться.</p>
                
                <h3>Interior Mutability</h3>
                <p>Тем не менее, существуют ситуации, когда было бы иметь возможность изменять данные, когда в коде имеется только immutable/shared ссылки на них. Для этого в Rust существует механизм обхода borrow checker: interior mutability.</p>
                
                <p>При interior mutability, проверка aliasing XOR mutability происходит во время выполнения: мы все еще не можем одновременно изменять один и тот же объект, но эти ограничения становятся куда мягче.</p>
                
                <p>Пример реализации interior mutability с использованием типа RefCell:</p>
                
                <pre><code class="language-rust">
use std::cell::RefCell;

fn main() {
    let x = RefCell::new(5);

    let y = &x; // immutable ссылка
    *y.borrow_mut() += 1; // изменяем данные через RefCell

    println!("y: {}", y.borrow());
}
            </code></pre>
                
                <p>Здесь RefCell позволяет изменять данные, даже если мы имеем ссылку на структуру как на неизменяемую.</p>
                
                <h3>Принципы работы с lifetime в Rust</h3>
                <p>В языке программирования Rust управление временем жизни объектов (или lifetime) является важной частью его системы безопасности памяти. В отличие от других языков, таких как C++ или Java, где работа с памятью контролируется в основном с помощью сборщика мусора или явного управления памятью, Rust использует строгую систему владения и заимствований. Эта система в сочетании с концепцией lifetime позволяет предотвратить ошибки, такие как висячие указатели или утечки памяти, без необходимости использовать сборщик мусора. Рассмотрим, как работает lifetime в Rust, зачем он нужен и как с ним работать.</p>
                
                <h4>Что такое lifetime?</h4>
                <p>Lifetime (или время жизни) — это концепция, которая позволяет компилятору Rust отслеживать, как долго существует объект в памяти и какие ссылки на этот объект действительны. С помощью lifetime Rust может гарантировать, что ссылки не станут висячими (не будут указывать на освобождённую память) и что заимствования не выходят за пределы существования объекта.</p>
                
                <p>Важной особенностью в Rust является то, что каждый объект в программе имеет определённое время жизни, и все ссылки должны быть действительными на протяжении этого времени. Система lifetime позволяет компилятору понять, когда объект может быть освобождён, и в какой момент ссылки на него могут стать недействительными.</p>
                
                <p>У каждого ссылочного типа данных имеется привязанный к ней lifetime, определяющий время жизни объекта, на который она указывает. Lifetime существует только во время компиляции и никак не влияет на скомпилированный код и его выполнение.</p>
                
                <h4>Почему необходимы lifetime?</h4>
                <p>Основная цель использования lifetime — это предотвращение ошибок, связанных с невалидными ссылками. В языке Rust заимствования и ссылки важны, но они ограничены временем жизни объекта. Например, если мы пытаемся вернуть ссылку на локальную переменную из функции, компилятор поймёт, что эта ссылка будет недействительна, как только функция завершит выполнение, и предотвратит такую ошибку. Правила Aliasing XOR Mutability также используют lifetime, чтобы понять, какие ссылки используются на данный момент.</p>
                
                <p>Пример использования lifetime:</p>
                
                <pre><code class="language-rust">
fn longest<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}
            </code></pre>
                
                <p>Здесь:</p>
                <ul>
                    <li>'a — это параметр lifetime. Он указывает, что оба параметра s1 и s2 имеют одинаковое lifetime, которое в конечном итоге будет определять и lifetime возвращаемой ссылки.</li>
                    <li>Функция longest принимает две ссылки на строки (s1 и s2) и возвращает ссылку на строку, которая имеет наибольшую длину.</li>
                    <li>Важно, что возвращаемая ссылка должна быть действительной в течение времени жизни обеих входных ссылок, и для этого используется параметр времени жизни 'a.</li>
                </ul>
                
                <p>Без указания lifetime компилятор не смог бы гарантировать, что возвращаемая ссылка будет действительна после завершения работы функции</p>
                
                <p>Пример ошибки:</p>
                
                <pre><code class="language-rust">
fn foo() -> &str {
    let s1 = String::from("Hello world!");
    return longest(&s1, "test")
}
            </code></pre>
                
                <p>Сообщение об ошибке:</p>
                <pre><code>
error[E0515]: cannot return value referencing local variable `s1`
    --> src/main.rs:5:5
    |
 5  |     return longest(&s1, "test");
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: `s1` is dropped here while still in use
</code></pre>
                
                <p>Если бы компилятор позволил бы такой код, то ссылка, возвращаемая функцией longest, указывала бы на уже освобождённую память, что привело бы к ошибке при работе программы.</p>

<h4>Параметры lifetime в функциях</h4>

<p>Когда функции принимают ссылки в качестве параметров или возвращают их, необходимо явно указать их времена жизни с помощью параметров lifetime. Параметры lifetime в сигнатурах функций объявляются с использованием символа <code>'</code>, как показано в предыдущем примере с параметром <code>'a</code>.</p>

<p>Время жизни указывается для ссылок, которые передаются в функцию, а также для возвращаемых значений. В некоторых случаях компилятор может вывести параметры lifetime, но в более сложных случаях разработчик должен явно указать их.</p>

<pre><code class="language-rust">
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }
    &s[..] // возвращаем строку, если пробела нет
}
</code></pre>

<p>В этой функции <code>first_word</code> принимает ссылку на строку <code>s</code> и возвращает ссылку на подстроку. Когда в функции используются несколько ссылок с разными сроками жизни, мы можем указать несколько параметров lifetime:</p>

<pre><code>
fn compare<'a, 'b>(s1: &'a str, s2: &'b str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}
</code></pre>

<p>Эта функция вызовет ошибку компиляции, поскольку она может вернуть параметр <code>s2</code> с другим lifetime.</p>

<h4>Структуры и lifetime</h4>

<p>Иногда мы работаем с структурами, содержащими ссылки, и в таких случаях необходимо указать время жизни для этих ссылок. Рассмотрим структуру, которая содержит ссылку:</p>

<pre><code>
struct Book<'a> {
    title: &'a str,
    author: &'a str,
}

fn create_book<'a>(title: &'a str, author: &'a str) -> Book<'a> {
    Book { title, author }
}
</code></pre>

<p>В этом примере структура <code>Book</code> содержит две строки: <code>title</code> и <code>author</code>, и у обеих строк время жизни <code>'a</code>. Функция <code>create_book</code> принимает ссылки на строки и создает структуру с этими строками.</p>

<h4>Static lifetime</h4>

<p>В Rust существует специальный параметр времени жизни, называемый <code>'static</code>. Это время жизни, которое длится на протяжении всей работы программы. Обычно используется для ссылок на строки, которые встроены в программу (например, строковые литералы).</p>

<pre><code class="language-rust">
fn greet<'a>(message: &'a str) {
    let greeting: &'static str = "Hello, ";
    println!("{}{}", greeting, message);
}
</code></pre>

<p>Здесь строка <code>"Hello, "</code> имеет время жизни <code>'static</code>, и её можно использовать в любом месте программы, независимо от времени жизни других ссылок.</p>

<h2>Контрольные вопросы</h2>
<ol>
    <li><strong>В чём заключается основное различие между независимой и мутабельной ссылкой в Rust? Приведите пример кода, где одновременно используются независимая и мутабельная ссылка на одну и ту же переменную. Какую ошибку при компиляции это вызовет?</strong></li>
    <li><strong>Объясните, что такое параметр lifetime (<code>'a</code>) в Rust. Как его использование помогает избежать ошибок с висячими указателями? Приведите пример функции, которая использует параметр времени жизни для возвращения ссылки на строку.</strong></li>
    <li><strong>В чём заключается правило «aliasing XOR mutability» в Rust? Приведите пример кода, который нарушает это правило, и объясните, почему это невозможно в Rust.</strong></li>
    <li><strong>Что такое interior mutability в Rust, и как оно связано с типами данных, такими как RefCell? Приведите пример использования RefCell для изменения данных через неизменяемую ссылку.</strong></li>
    <li><strong>Как работает компилятор Rust с параметрами времени жизни в функциях, которые принимают несколько ссылок с разными временами жизни? Приведите пример, когда компилятор не может вернуть ссылку, потому что время жизни возвращаемой ссылки не совпадает с временем жизни переданных аргументов.</strong></li>
</ol>

<h2>Упражнения для самостоятельной работы</h2>
<h3>Задачи</h3>
<ol>
    <li>Создайте объект хэш-таблицы с логированием числа чтений из нее. Чтение из таблицы все еще должно требовать только immutable ссылки.</li>
    <li>Реализуйте итератор для обхода бинарного дерева (<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a>).</li>
    <li>Реализуйте Copy-On-Write строку: по умолчанию она владеет строкой (тип String), но при клонировании она не копирует всю строку, а лишь создает новую ссылку на нее (<code>&str</code>). При этом при любом изменении строки (например добавлении символов), вся строка полностью копируется и преобразуется в <code>String</code>.</li>
</ol>

<h3>Пример выполнения упражнения</h3>
<p><strong>Упражнение:</strong> Реализуйте итератор для обхода бинарного дерева (<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">https://doc.rust-lang.org/std/iter/trait.Iterator.html</a>).</p>

<pre><code class="language-rust">
// Определение структуры для бинарного дерева
enum Tree<T> {
    Leaf(T), // Лист с данными типа T
    Node(Box<Tree<T>>, Box<Tree<T>>), // Внутренний узел с двумя потомками
}

// Итератор для обхода бинарного дерева в глубину
struct TreeIterator<'a, T> {
    stack: Vec<&'a Tree<T>>, // Стэк для хранения узлов
}

impl<'a, T> TreeIterator<'a, T> {
    fn new(root: &'a Tree<T>) -> Self {
        let mut stack = Vec::new();
        stack.push(root);
        TreeIterator { stack }
    }
}

// Реализация итератора для обхода дерева
impl<'a, T> Iterator for TreeIterator<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        // Если стек пуст, значит мы прошли все элементы
        if let Some(node) = self.stack.pop() {
            match node {
                Tree::Leaf(value) => {
                    // Если это лист, возвращаем его значение
                    Some(value)
                }
                Tree::Node(left, right) => {
                    // Если это узел, сначала добавляем правого потомка (чтобы он был обработан позже)
                    self.stack.push(&right);
                    self.stack.push(&left);
                    None // Возвращаем None, потому что мы будем обрабатывать потомков позже
                }
            }
        } else {
            None
        }
    }
}
</code></pre>


            </section>
        </main>

        <footer>
            <p>Подготовил Максим Мичков, 2024.</p>
        </footer>
    </div>
</body>
</html>
