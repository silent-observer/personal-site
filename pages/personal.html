<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Персональный сайт</title>
    <link rel="stylesheet" href="../styles/styles.css">
</head>
<body class="dark">
    <div class="container">
        <header>
            <h1>Максим Мичков</h1>
            <nav>
                <ul>
                    <li><a href="index.html">Главная</a></li>
                    <li><a href="resume.html">Резюме</a></li>
                    <li><a href="biography.html">Биография</a></li>
                    <li><a href="presentation.html">Реферат</a></li>
                    <li><a href="library.html">Библиотека</a></li>
                    <li><a href="links.html">Ссылки</a></li>
                    <li><a href="search-report.html">Отчет о поиске</a></li>
                    <li><a href="personal.html">Индивидуальный раздел</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <section class="presentation">
                <h2>Эффективная симуляция для встроенного ПО</h2>
                <p><b>Ключевые слова</b>: симуляция, дискретно-событийное моделирование, встроенное ПО, микроконтроллер, JIT компиляция.</p>
                <h3>Аннотация</h3>
                <p>Описана модульная архитектура симулятора для встроенных систем, позволяющая моделировать их работу и тестировать встроенное ПО. Данная архитектура легко расширяема дополнительными компонентами, и при этом также обладает высокой эффективностью симуляции, во многих случаях достигая симуляции в реальном времени.</p>

                <p>Встроенные (embedded) системы – это специализированные системы управления, зачастую состоящие из многих взаимодействующих микроконтроллеров и периферийных устройств. Для упрощения тестирования ПО для таких систем возможно применять компьютерное моделирование. Системы моделирования встроенных систем при этом должны быть способны симулировать не только работу самих микроконтроллеров, но и все взаимодействия между различными компонентами системы.</p>
                <p>Разделение системы на независимые компоненты позволяет легко расширять функциональность симулятора [1], в связи с чем рассматриваемая в данной работе архитектура симулятора является модульной. Некоторые из этих модулей для своей работы требуют тактовый сигнал (например, процессор должен выполнять инструкции с заданной тактовой частотой, 16 МГц в случае ATmega2560). Такие модули называются «активными» и содержат внутри собственный тактовый генератор. Остальные же модули, не требующие тактового сигнала, являются «пассивными».</p>
                <p>Поскольку активные модули содержат независимые тактовые сигналы, их симуляцию возможно выполнять в различных потоках (при условии синхронизации между тактовыми генераторами). Тем не менее, синхронизация добавляет дополнительные временные затраты, из-за чего желательно как можно большее число модулей реализовать в «пассивном» стиле – как модули, получающие запросы на чтение/запись от активных модулей.</p>
                <p>Такого подхода достаточно для реализации некоторых частей микроконтроллера в качестве пассивных модулей, например, контроллеров GPIO. Для реализации остальных модулей как пассивных требуется также поддержка асинхронных событий. Если пассивные модули при записи значений будут также способны планировать события, которые произойдут в будущем, то это также позволит реализовать более сложные компоненты, например, таймеры. Подобная реализация таймеров при помощи асинхронных событий значительно эффективнее чем более очевидная реализация таймеров как активных модулей, увеличивающих внутренние счетчики с каждым тактом процессора.</p>
                <p>Для реализации асинхронных событий используется так называемая «очередь событий» – приоритетная очередь, в которой события отсортированы по их времени. При записи значения в пассивный модуль возможно добавление события в очередь событий. При этом при каждом такте активного модуля события в очереди проверяются и, по необходимости, выполняются.</p>
                <p>В некоторых ситуациях события могут быть адресованы не модулю-отправителю, а какому-либо другому модулю, например, когда таймер отправляет прерывание на ядро процессора. Для реализации таких событий необходима некоторая система адресации. Более того, поскольку новые события определяются во время такта активного модуля, а обрабатываются – пассивными, то активный модуль должен иметь доступ ко всем пассивным модулям, которые используют данную очередь событий.</p>
                <p>Для решения данной проблемы предлагается следующая архитектура – каждый активный модуль содержит в себе очередь событий, которая к нему привязана, а также набор пассивных модулей внутри себя. Пассивные модули могут располагаться иерархически, т.е. содержать в себе другие пассивные модули (рис. 1). Активный модуль является корневым модулем для адресации, и все остальные модули являются подмодулями активного. </p>

                <div class="img-container">
                    <img src="../assets/img3.png" alt="Иерархическая структура модулей">
                    <p class="img-label">Рисунок 1 – Иерархическая структура модулей</p>
                </div>

                <p>Для сообщения между модулями используется система проводных соединений, повторяющая симулируемую систему. Модули могут содержать порты, к которым возможно подключить «провода», соединяющие их с другими модулями, в том числе принадлежащим другим активным модулям. Каждый активный модуль имеет собственный MPSC-канал, по которому ему возможно отправлять сообщения о изменении состояния проводного соединения.</p>
                <p>Важной частью системы проводных соединений в симуляторе также являются мультиплексоры. Каждый мультиплексор проводит соответствие между одним «внешним» контактом и несколькими «внутренними» контактами (рис. 2). Каждому из «внутренних» контактов также назначен булевый флаг. В каждый конкретный момент «активным» считается первый по очередности «внутренний» контакт, булевый флаг которого имеет истинное значение. </p>

                <div class="img-container">
                    <img src="../assets/img5.png" alt="Схема мультиплексора">
                    <p class="img-label">Рисунок 2 – Схема мультиплексора</p>
                </div>

                <p>Симуляция при помощи интерпретации связана с большими затратами времени, что делает ее малопригодной в ситуациях, когда требуется высокая эффективность [2]. Поскольку в коде микроконтроллеров зачастую используются переходы по неявным адресам (например, как результат компиляции switch-конструкций), статическая компиляция также зачастую оказывается невозможной. В связи с этим, в качестве основного механизма симуляции предлагается использовать Just In Time компиляцию.</p>
                <p>При JIT компиляции, преобразование кода микропроцессора в машинный код хоста происходит не полностью при загрузке программы, а постепенно в процессе выполнения. Для этого используется так называемый «кэш единиц трансляции» (рис. 3). Этот кэш представляет собой хэш-таблицу [3], использующую адрес начальной инструкции как ключ, и хранящую в себе уже скомпилированные участки кода. На каждом шаге симулятор ищет участок кода, соответствующий его текущему значению счетчика команд (или компилирует его, если он отсутствует), и выполняет его. В результате выполнения изменяются регистры процессора, выполняются операции ввода-вывода, и значение счетчика команд меняется на новое.</p>

                <div class="img-container">
                    <img src="../assets/img6.png" alt="Схема JIT-компилятора">
                    <p class="img-label">Рисунок 3 – Схема JIT-компилятора</p>
                </div>
                <p>Для оценки эффективности были проведены замеры времени симуляции нескольких тестовых программ. Замеры проведены для двух симуляторов, один из которых использует вышеописанную модульную архитектуру, а второй является более простой реализацией без асинхронных событий. Для каждого из тестов симуляция длилась 10 секунд модельного времени. Результаты приведены в таблице 1.</p>
                <div class="img-container">
                    <img src="../assets/img7.png" alt="Результаты исследования">
                    <p class="img-label">Таблица 1 – Результаты исследования</p>
                </div>

                <h3>Библиографический список</h3>
                <ol>
                    <li>An efficient retargetable framework for instruction-set simulation / M. Reshadi, N. Bansal, P. Mishra, N. Dutt // First IEEE/ACM/IFIP International Conference on Hardware/ Software Codesign and Systems Synthesis (IEEE Cat. No.03TH8721). – 2003. – P. 13-18. – DOI 10.1109/CODESS.2003.1275249.</li>
                    <li>Zhu, J. An ultra-fast instruction set simulator / J. Zhu, D. Gajski // Very Large Scale Integration (VLSI) Systems, IEEE Transactions on. – 10. – 2002. – P. 55-95. – DOI 10.1109/TVLSI.2002.1043339.</li>
                    <li>Jones, D. High Speed CPU Simulation Using LTU Dynamic Binary Translation / D. Jones, N. Topham // High Performance Embedded Architectures and Compilers. – 2009. – P. 50-64. – ISBN 978-3-540-92990-1.</li>
                </ol>
            </section>
        </main>

        <footer>
            <p>Подготовил Максим Мичков, 2024.</p>
        </footer>
    </div>
</body>
</html>
