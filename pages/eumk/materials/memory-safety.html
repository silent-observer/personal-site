<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ЭУМК</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

    <!-- and it's easy to individually load additional languages -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/rust.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>

    <script>hljs.highlightAll();</script>
    <link rel="stylesheet" href="../../../styles/styles.css">
</head>
<body class="dark">
    <div class="container">
        <header>
            <h1>Основы Rust</h1>
            <nav>
                <ul>
                    <li><a href="../index.html">Главная</a></li>
                    <li><a href="../curriculum.html">Программа</a></li>
                    <li><a href="../sources.html">Источники</a></li>
                    <li><a href="../materials.html">Учебный материал</a></li>
                    <li><a href="../tests.html">Тесты</a></li>
                    <li><a href="../tasks.html">Задания</a></li>
                    <li><a href="../../index.html">Об авторе</a></li>
                </ul>
            </nav>
        </header>

        <main>
            <section>
                <h2>Теоретический материал по разделу "Безопасность памяти"</h2>

<p>Проблемы безопасности памяти являются важной частью разработки программного обеспечения, особенно в языках программирования низкого уровня, таких как C и C++. Нарушения безопасности памяти могут привести к различным уязвимостям, включая утечку памяти, повреждение данных, несанкционированный доступ или выполнение произвольного кода. Это может быть особенно критично в системах, где надежность и безопасность имеют решающее значение, например, в операционных системах, встраиваемых системах и приложениях для финансовых операций. Далее мы рассмотрим основные проблемы безопасности памяти, такие как пространственные и временные ошибки, а также способы их предотвращения и управления памятью, включая сборщики мусора, подсчет ссылок и другие методы.</p>

<h3>Пространственные ошибки (Spatial Errors)</h3>
<p>Пространственные ошибки в контексте управления памятью происходят, когда программа обращается к памяти вне выделенного для нее диапазона. Это может быть вызвано ошибками в индексации массивов, нарушением границ буферов или некорректным использованием указателей. Основными видами пространственных ошибок являются:</p>
<ul>
    <li><strong>Переполнение буфера (Buffer Overflow)</strong> — происходит, когда программа записывает больше данных в буфер, чем тот может вместить, что приводит к записи за пределы выделенной памяти. Это может привести к перезаписи соседних данных, повреждению памяти или возможности исполнения произвольного кода.</li>
    <li><strong>Недостаточное выделение памяти (Underflow)</strong> — ошибка возникает, когда выделяется меньше памяти, чем необходимо для хранения данных, что может привести к доступу к неинициализированной или уже освобожденной памяти.</li>
</ul>

<h4>Пример переполнения буфера на C++:</h4>
<pre><code class="language-cpp">
#include &lt;iostream&gt;

void overflow_example() {
    int buffer[10];
    for (int i = 0; i <= 10; ++i) {
        buffer[i] = i;  // Переполнение буфера, при i = 10
    }
}
</code></pre>
<p>В данном примере происходит выход за пределы массива <code>buffer</code>, что может привести к повреждению памяти.</p>

<h3>2.2.2 Временные ошибки (Temporal Errors)</h3>
<p>Временные ошибки возникают, когда программа обращается к памяти, которая была освобождена, или пытается использовать неинициализированную память. Это может привести к различным последствиям, таким как неопределенное поведение или утечка памяти. Временные ошибки включают:</p>
<ul>
    <li><strong>Use After Free (UAF)</strong> — ошибка возникает, когда программа обращается к памяти, которая была освобождена, но указатель на неё всё ещё используется. Это может привести к повреждению данных или к выполнению произвольного кода, если память была перераспределена под другие нужды.</li>
</ul>

<h4>Пример Use After Free на C++:</h4>
<pre><code class="language-cpp">
#include &lt;iostream&gt;

void use_after_free() {
    int* ptr = new int(42);
    delete ptr;
    std::cout << *ptr << std::endl;  // Использование освобожденной памяти
}
</code></pre>
<p>Здесь программа использует указатель <code>ptr</code> после того, как память была освобождена, что может привести к неопределенному поведению.</p>

<ul>
    <li><strong>Double Free</strong> — ошибка возникает, когда программа дважды пытается освободить один и тот же блок памяти. Это может привести к повреждению памяти, утечке памяти или уязвимостям в безопасности.</li>
</ul>

<h4>Пример Double Free на C++:</h4>
<pre><code class="language-cpp">
#include &lt;iostream&gt;

void double_free() {
    int* ptr = new int(42);
    delete ptr;
    delete ptr;  // Двойное освобождение памяти
}
</code></pre>
<p>Двойное освобождение памяти может нарушить состояние памяти и вызвать критические ошибки.</p>

<ul>
    <li><strong>Неинициализированная память (Uninitialized Memory)</strong> — ошибка возникает, когда программа использует переменную или указатель, который не был предварительно инициализирован. Это может привести к непредсказуемым результатам, так как память может содержать мусорные значения.</li>
</ul>

<h4>Пример неинициализированной памяти:</h4>
<pre><code class="language-cpp">
#include &lt;iostream&gt;

void uninitialized_memory() {
    int x;  // Неинициализированная переменная
    std::cout << x << std::endl;  // Использование неинициализированной памяти
}
</code></pre>
<p>В этом примере переменная <code>x</code> не инициализируется перед использованием, что может привести к неопределенному поведению.</p>

<h3>2.2.3 Методы обеспечения безопасности памяти</h3>
<h4>Сборщик мусора (Garbage Collector)</h4>
<p>Сборщик мусора — это механизм, который автоматически управляет выделением и освобождением памяти. Он отслеживает объекты, которые больше не используются программой, и освобождает их, освобождая память. Сборщик мусора решает проблему утечек памяти, так как память автоматически освобождается, когда объект больше не нужен.</p>
<p>Пример использования сборщика мусора можно встретить в языках, таких как Java или Python. В C++, Rust и других языках, работающих с явным управлением памятью, сборщик мусора не используется, и программист сам отвечает за управление памятью.</p>

<h4>Подсчет ссылок (Reference Counting)</h4>
<p>Подсчет ссылок — это метод управления памятью, при котором каждый объект отслеживает количество ссылок на него. Когда количество ссылок на объект становится равным нулю, объект автоматически удаляется. В Rust для его использования существуют типы Rc и Arc.</p>
<ul>
    <li><strong>Rc (Reference Counted)</strong> используется для управления памятью в однопоточных приложениях. Он отслеживает количество ссылок на объект, и когда их становится ноль, память освобождается.</li>
    <li><strong>Arc (Atomic Reference Counted)</strong> — расширение Rc, которое работает в многопоточных средах, используя атомарные операции для управления счетчиком ссылок.</li>
</ul>

<h4>Пример использования Rc в Rust:</h4>
<pre><code class="language-rust">
use std::rc::Rc;

fn main() {
    let a = Rc::new(42);
    let b = Rc::clone(&a);
    println!("{}", a);
}
</code></pre>
<p>В этом примере память под число 42 будет автоматически освобождена, когда все ссылки на нее (a и b) будут уничтожены.</p>

<h4>Санитайзеры</h4>
<p>Санитайзеры — это инструменты, которые помогают выявить ошибки безопасности памяти, такие как утечки памяти, доступ к неинициализированной памяти, и другие. Одним из самых известных является AddressSanitizer (ASan), который позволяет обнаруживать ошибки, связанные с памятью в процессе выполнения программы.</p>

<p>Для включения AddressSanitizer в C++ проект, нужно скомпилировать программу с флагом <code>-fsanitize=address</code>:</p>
<pre><code>g++ -fsanitize=address -g program.cpp -o program</code></pre>
<p>Санитайзер будет проверять корректность работы с памятью и выводить сообщения об ошибках. К сожалению, эта проверка происходит во время работы программы и замедляет ее примерно в 3 раза, что не дает использовать это в релизных сборках. Тем не менее, использование санитайзеров крайне полезно во время тестирования и практически необходимо для небезопасных языков типа C++.</p>

<h4>RAII (Resource Acquisition Is Initialization)</h4>
<p>RAII — это идиома программирования, при которой ресурсы (в том числе память) захватываются в конструкторе и освобождаются в деструкторе объекта. В Rust это реализуется через трейт Drop. Когда объект выходит из области видимости, его метод drop автоматически вызывается, и ресурсы освобождаются.</p>

<h4>Пример использования Drop в Rust:</h4>
<pre><code class="language-rust">
struct MyStruct {
    data: String,
}

impl Drop for MyStruct {
    fn drop(&mut self) {
        println!("Releasing resources: {}", self.data);
    }
}

fn main() {
    let obj = MyStruct { data: String::from("Hello") };
    // Ресурсы освобождаются автоматически при выходе из области видимости
}
</code></pre>
<p>Здесь метод drop будет вызван при выходе из области видимости переменной <code>obj</code>, что гарантирует освобождение ресурсов.</p>

<h2>Контрольные вопросы</h2>
<ol>
    <li>В чем отличие между пространственными и временными ошибками в контексте управления памятью? Приведите примеры обеих категорий.</li>
    <li>Что такое ошибка «use-after-free» и как она может повлиять на программу? Приведите пример кода на C++, который демонстрирует эту ошибку.</li>
    <li>Объясните, что такое «double-free» ошибка, как она может возникнуть и какие последствия могут быть при ее возникновении. Приведите пример на C++.</li>
    <li>Что такое подсчет ссылок (reference counting), и как он используется в языке Rust с типами Rc и Arc? Объясните, чем они отличаются.</li>
    <li>Какие преимущества дает использование санитайзеров, таких как AddressSanitizer, для обнаружения ошибок безопасности памяти? Как можно использовать AddressSanitizer в C++ проекте?</li>
</ol>

<h2>Упражнения для самостоятельной работы</h2>
<h3>Задачи</h3>
<ol>
    <li>Найдите ошибку в следующей программе и объясните, почему она возникает и как ее исправить.</li>
</ol>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Data {
    int key;
    int value;
};

std::vector&lt;Data*&gt; fill(int n) {
    std::vector&lt;Data*&gt; result;
    for (int i = 0; i < n; i++) {
        Data* d = new Data;
        d->key = i;
        d->value = i * 10;
        result.push_back(new);
    }
    return result;
}

Data *find(const std::vector&lt;Data*&gt; &v, int key) {
    for (int i = 0; i < v.size(); i++) {
        if (v[i]->key == key)
            return v[i];
    }
    return NULL;
}

void modify(std::vector&lt;Data*&gt; &v, int key) {
    for (int i = 0; i < v.size(); i++) {
        if (v[i]->key == key) {
            int value = v[i]->value;
            delete v[i];
            v[i] = new Data;
            d->key = key;
            d->value = value * 10;
        }
    }
}

void main() {
    std::vector&lt;Data*&gt; v = fill(100);
    Data *d = find(v, 5);
    modify(v, d->key);
    modify(v, d->key * 2);
}
</code></pre>

<ol start="2">
    <li>Найдите ошибку в следующей функции удаления графа:</li>
</ol>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Node {
    int data;
    vector<Node*> connected_to;
};

void deleteNode(Node *n) {
    for (Node* n2 : n->connected_to) 
        deleteNode(n2);
    delete n;
}
</code></pre>

<ol start="3">
    <li>Напишите программу для создания графа на Rust с использование Rc. В программе должны быть методы для создания новых узлов и добавления ребер.</li>
</ol>

<h2>Пример выполнения упражнения</h2>
<p><strong>Упражнение</strong>: Найдите ошибку в следующей функции удаления графа</p>
<p>При рекурсивном удалении связей, вполне может произойти что один и тот же узел будет посещен 2 раза, после чего произойдет double free. Подобный алгоритм удаления дерева подходит лишь для деревьев (графов без циклов), для более общих графов необходим учет того, какие узлы уже были посещены, а какие нет.</p>

            </section>
        </main>

        <footer>
            <p>Подготовил Максим Мичков, 2024.</p>
        </footer>
    </div>
</body>
</html>
